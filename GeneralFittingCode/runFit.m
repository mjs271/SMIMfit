%===============================================================================
%===============================================================================
%
% This function runs the optimization problem that fits the forward SMIM model
% to data.
%
% NOTE: Currently, the optimization function is hard-coded to be lsqnonlin(),
%       but this could be generalized, if desired.
%
%===============================================================================
%
% Inputs:
%   mymeas       := measurement (conservative or reactive)
%   obj_function := function handle for the objective function to be minimized
%   data         := struct provided to the objective function--objFunctionSMIM()
%                   for further information
%   pdf_function := function handle for the pdf function that is provided to the
%                   objective function--this is the SMIM forward model, and is
%                   set in SMIMfit()
%   params_guess := initial guess for parameters to be fitted by the optimization function
%   params_upper := upper bound for the parameters to be fitted
%   params_lower := lower bound for the parameters to be fitted
%   varargin     := optional input (only when called during the reactive
%                   fit), holding:
%       - transParams := transport parameters generated by the conservative fit
%
% Outputs:
%   M := struct containing the results of the fit--see SMIMfit() for details
%
%===============================================================================
%===============================================================================

function M = runFit(mymeas, obj_function, data, pdf_function,...
                    params_guess, params_upper, params_lower, varargin)

p = inputParser;

% error checking functions
checkMeas = @(x) any(validatestring(x, {'c', 'r'}));
checkFunc = @(x) isa(x, 'function_handle');

% measurement, must be 'c' (conservative) or 'r' (reactive)
addRequired(p, 'mymeas', checkMeas);
addRequired(p, 'obj_function', checkFunc);
addRequired(p, 'data', @(x) isstruct(x));
addRequired(p, 'pdf_function', checkFunc);
addRequired(p, 'params_guess', @(x) isnumeric(x) && isvector(x));
addRequired(p, 'params_upper', @(x) isnumeric(x) && isvector(x));
addRequired(p, 'params_lower', @(x) isnumeric(x) && isvector(x));

% transport parameters--to be passed in when doing reactive fit
% NOTE: this is currently hard-coded to length 6, corresponding to the TPL
%     model
addParameter(p, 'transParams', @(x) isnumeric(x) && isvector(x) && length(x) == 6);

parse(p, mymeas, obj_function, data, pdf_function,...
      params_guess, params_upper, params_lower, varargin{:});

params_transport = p.Results.transParams;

switch mymeas
    case 'c'
%         get the optimization function options
        [fopts , iterFit, iterFitRandRestart] = getOptInputs(mymeas);
%         there are no known parameters, as we are trying to fit all
%         transport parameters
%             NOTE(mjs): this could be generalized, if the user only wanted to
%             fit a subset of the transport parameters. It would require some
%             cleverness, but I would, perhaps, suggest passing in an index
%             vector here via the above function getOptInputs()
        knownParams = [];
    case 'r'
%         get the optimization function options
        [fopts , iterFit, iterFitRandRestart, fitTransParams] = getOptInputs(mymeas);
        if fitTransParams == false
%             this assumes transport parameters are known so that the
%             optimization function does not run in extra dimensions
            knownParams = params_transport;
        else
            knownParams = [];
        end
end

% objective function handle with  options, as a function of only
% the parameters we wish to fit
f = @(fitParams) obj_function([knownParams fitParams], 1, data, pdf_function);

algout          = struct;
params_allfits  = zeros(iterFit + iterFitRandRestart, length(params_guess));
obj_fcn_allfits = zeros(iterFit + iterFitRandRestart, 1);

params_newguess = params_guess;
for n_iter = 1 : iterFit
    [params_allfits(n_iter, :), algout(n_iter).resnorm, algout(n_iter).residual,...
     algout(n_iter).exitflag, algout(n_iter).output] =...
               lsqnonlin(f, params_newguess, params_lower, params_upper, fopts);
    algout(n_iter).params_guess = params_newguess; % record parameter guesses
    obj_fcn_allfits(n_iter) = algout(n_iter).resnorm;
%     randomize the next guess
    params_newguess = (params_upper - params_lower) .*...
                      rand(size(params_lower)) + params_lower;
end

bestfit = find(obj_fcn_allfits == min(obj_fcn_allfits), 1);
params_bestfit_temp = params_allfits(bestfit, :);

if iterFitRandRestart > 0
    for n_iter = 1 : iterFitRandRestart
        params_smallrand = params_bestfit_temp + randn(size(params_bestfit_temp)) * 0.2;
        [params_allfits(iterFit + n_iter, :), algout(iterFit + n_iter).resnorm,...
         algout(iterFit + n_iter).residual, algout(iterFit + n_iter).exitflag,...
         algout(iterFit + n_iter).output]...
            = lsqnonlin(f, params_smallrand, params_lower, params_upper, fopts);
        obj_fcn_allfits(iterFit + n_iter) = algout(n_iter).resnorm;
    end
end

bestfit    = find(obj_fcn_allfits == min(obj_fcn_allfits), 1);
params_fit = params_allfits(bestfit, :);

% write out the results to the results struct
M.params_fit              = params_fit;
M.opts.iterFitRandRestart = iterFitRandRestart;
M.opts.iterFit            = iterFit;
M.opts.mytol              = fopts.FunctionTolerance;
M.opts.params_upper       = params_upper;
M.opts.params_lower       = params_lower;
M.opts.params_guess       = params_guess;

M.obj_fcn_result          = algout(bestfit).residual;
M.SSE                     = algout(bestfit).resnorm;
M.fitdate                 = datetime('now');
M.allfits                 = params_allfits;
M.obj_fcn_allfits         = obj_fcn_allfits;
M.algout                  = algout;

% write the fitted concentration curve to the results struct
%     NOTE: not sure if the 'ccfit' vs. 'crfit' convention is strictly
%     necessary, but decided to keep it as is
switch mymeas
    case 'c'
        M.ccfit = pdf_function([knownParams M.params_fit], data);
    case 'r'
        M.crfit = pdf_function([knownParams M.params_fit], data);
end



end
